链表：
1、数据存储在“节点”中
2、真正的动态，不需要处理固定容量的问题
3、丧失了随机访问的能力
4、链表不适合用于索引有语意的情况

时间复杂度：
增：O(n)  如果只对链表头进行操作：O(1)
删：O(n)  如果只对链表头进行操作：O(1)
改：O(n)
查：O(n)  如果只查链表头的元素：O(1)

如果增加一个tail指针，对链表尾增、查操作O(1)

应用：
1、用链表头作为栈顶，push、pop、peek时间复杂度O(1)
与数组实现栈比较：
1)数组需要resize操作
2)链表栈包含更多的new操作

2、链表队列：从head端删除元素(出队),从tail端添加元素（入队）





递归：
1、本质上，将原来的问题，转化为更小的同一问题
例如：数组求和：Sum(arr[0...n-1]) = arr[0]+Sum(arr[1...n-1])

可以分两个步骤：
    1)求解最基本问题（递归终止条件）
    2）把原问题转化成更小的问题（递推关系）

    如：计算arr[l...n)范围里的数字和
    public static int sum(int[] arr,int l) {
        if (l == arr.length) { // 求解最基本问题
            return 0;
        }
        return arr[l]+sum(arr,l+1); // 把原问题转换为更小的问题
    }

2、注意递归函数的”宏观“语意
3、递归函数就是一个函数，完成一个功能
4、把递归过程理解为一个子过程

